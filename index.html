<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>üî™ Liver VR Surgical Simulator (A-Frame)</title>
  <!-- Use jsdelivr for better reliability -->
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.4.2/dist/aframe.min.js"></script>
  
  <style>
    body { background: #111; overflow: hidden; font-family: 'Courier New', monospace; }
    
    /* 2D Overlay UI */
    #info {
      position: fixed; top: 12px; left: 12px;
      background: rgba(0,0,0,0.85); color: #fff; padding: 14px 18px; border-radius: 10px;
      font: 11px 'Courier New', monospace; z-index: 100; border: 1px solid #444; line-height: 2.1;
      backdrop-filter: blur(8px); max-width: 270px; pointer-events: none; /* Let clicks pass through to canvas */
    }
    #info h3 { color: #ff6644; margin-bottom: 6px; font-size: 13px; letter-spacing: 1px; }
    #info span { color: #ffdd00; }
    #status-text { color: #44ff88; font-weight: bold; margin-top: 6px; }
    #ncuts { color: #ffaa00; }
    #vrinfo { color: #88aaff; font-size: 10px; margin-top: 4px; border-top: 1px solid #333; padding-top: 4px; }

    #legend {
      position: fixed; top: 12px; right: 12px;
      background: rgba(0,0,0,0.85); color: #fff; padding: 12px 16px; border-radius: 10px;
      font: 11px 'Courier New', monospace; z-index: 100; border: 1px solid #444; line-height: 2;
      backdrop-filter: blur(8px); pointer-events: none;
    }
    #legend h3 { color: #aaa; font-size: 10px; letter-spacing: 2px; margin-bottom: 4px; }
    .dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }

    /* Buttons */
    #bar {
      position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 8px; z-index: 100;
    }
    .ui-btn {
      background: rgba(17,17,17,0.9); border: 1px solid #555; color: #ccc;
      padding: 10px 18px; border-radius: 8px; cursor: pointer;
      font: 12px 'Courier New', monospace; transition: all .15s;
      backdrop-filter: blur(4px); pointer-events: auto;
    }
    .ui-btn:hover { background: rgba(60,60,60,0.9); color: #fff; border-color: #aaa; }

    #bowl-status {
      position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.85); color: #ffcc44;
      padding: 8px 18px; border-radius: 8px; font: 12px 'Courier New', monospace;
      z-index: 100; border: 1px solid #664400; display: none; backdrop-filter: blur(4px);
    }
  </style>

  <script>
    // ‚îÄ‚îÄ‚îÄ GLOBAL STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let state = {
      cutCount: 0,
      tumorResected: false,
      tumorCutCount: 0,
      cutsToResect: 8,
      tumorInBowl: false,
      tumorFlying: false,
      flyTime: 0,
      flyStart: null,
      flyTarget: null,
      
      // Toggles
      tumorOn: true,
      nervesOn: true,
      vesselsOn: true
    };

    // References to important entities (populated by components)
    let els = {
      liverGroup: null,
      tumor: null,
      tumorGlow: null,
      progressRing: null,
      internals: [],
      wounds: []
    };

    function updateStatus(msg, color) {
      const statusEl = document.getElementById('status-text');
      const vrStatusEl = document.getElementById('vr-status');
      
      if(statusEl) {
        statusEl.innerText = msg;
        statusEl.style.color = color || '#fff';
      }
      if(vrStatusEl) {
        vrStatusEl.setAttribute('value', msg);
        vrStatusEl.setAttribute('color', color || '#fff');
        vrStatusEl.setAttribute('visible', true);
      }
    }

    // ‚îÄ‚îÄ‚îÄ COMPONENT: LIVER GENERATOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    AFRAME.registerComponent('liver-generator', {
      init: function () {
        els.liverGroup = this.el;
        const scene = this.el.sceneEl.object3D;

        // Helper to add Three.js mesh to Entity
        const addMesh = (mesh) => {
          this.el.object3D.add(mesh);
        };

        // 1. LIVER LOBES
        const lobeMat = new THREE.MeshPhongMaterial({
          color: 0xcc3300, specular: 0x441100, shininess: 40
        });
        
        const createLobe = (x, y, z, rx, ry, rz) => {
          const geo = new THREE.SphereGeometry(1, 64, 40);
          const mesh = new THREE.Mesh(geo, lobeMat);
          mesh.scale.set(rx, ry, rz);
          mesh.position.set(x, y, z);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          // Add class for raycaster
          mesh.userData.isLiver = true;
          addMesh(mesh);
        };

        createLobe(0.0, 0.0, 0.0, 4.5, 2.6, 3.2);
        createLobe(2.9, -0.2, 0.2, 2.8, 2.1, 2.8);
        createLobe(-2.4, 0.3, 0.0, 2.1, 1.8, 2.4);
        createLobe(0.4, 1.7, -0.6, 1.1, 0.7, 0.9);
        createLobe(0.9, -1.3, 1.0, 1.0, 0.7, 0.85);

        // Gallbladder
        const gb = new THREE.Mesh(
          new THREE.SphereGeometry(0.55, 24, 16),
          new THREE.MeshPhongMaterial({ color: 0x44aa10, shininess: 40 })
        );
        gb.scale.set(1, 1.5, 1);
        gb.position.set(2.7, -2.2, 1.2);
        gb.castShadow = true;
        addMesh(gb);

        // 2. INTERNAL ANATOMY
        const internalGroup = new THREE.Group();
        this.el.object3D.add(internalGroup);

        const iTube = (ax,ay,az, bx,by,bz, r, hex, name) => {
          const A = new THREE.Vector3(ax,ay,az);
          const B = new THREE.Vector3(bx,by,bz);
          const mid = A.clone().add(B).multiplyScalar(0.5);
          const len = A.distanceTo(B);
          const geo = new THREE.CylinderGeometry(r, r*0.85, len, 12);
          const mat = new THREE.MeshPhongMaterial({ color: hex, shininess: 60 });
          const m = new THREE.Mesh(geo, mat);
          m.position.copy(mid);
          m.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), B.clone().sub(A).normalize());
          m.visible = false;
          m.userData = { name, revealed: false };
          internalGroup.add(m);
          els.internals.push(m);
        };

        const iBlob = (x,y,z,r, hex, name) => {
          const m = new THREE.Mesh(new THREE.SphereGeometry(r, 18, 12), new THREE.MeshPhongMaterial({ color: hex, shininess: 40 }));
          m.position.set(x,y,z);
          m.visible = false;
          m.userData = { name, revealed: false };
          internalGroup.add(m);
          els.internals.push(m);
        };

        // Generating Anatomy
        // Hepatic Artery
        iTube(0,-2.5, .4, 0, 2.5, .4, .18, 0xff2222,'artery');
        iTube(0, .5, .4, 3.2,.9, .5, .12, 0xff2222,'artery');
        iTube(0, .5, .4, -3.0,.8, .5, .11, 0xff2222,'artery');
        // Portal Vein
        iTube(0,-2.0, 0, 0, .8, 0, .32, 0xdd22aa,'portal');
        iTube(0, 0, 0, 3.0, .5, .1, .23, 0xdd22aa,'portal');
        iTube(0, 0, 0, -2.8, .4, .1, .20, 0xdd22aa,'portal');
        // Bile Ducts
        iTube(-.1, 2.0,-.6, -.1,-1.5,-.6, .10, 0xaadd00,'bile');
        iTube(-.1, .6,-.6, 2.8, .9,-.5, .08, 0xaadd00,'bile');
        // Veins
        iTube(.2, 2.8,-.7, .2,-1.5,-.3, .26, 0x2244ff,'hepaticV');
        // Nerves
        iTube(.7, 1.5, 1.9, .7,-1.5,1.9, .045, 0xffee00,'nerve');
        iTube(-.6, 1.3, 2.0, -.6,-1.3,2.0, .038, 0xffee00,'nerve');
        
        // Random Sinusoids
        for(let i=0; i<22; i++) {
          iBlob((Math.random()-.5)*6.5, (Math.random()-.5)*4.5, (Math.random()-.5)*4.0, .05+Math.random()*.14, 0xdd2222,'sinusoid');
        }

        // 3. TUMOR
        const tumorMat = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xaa0000, shininess: 80 });
        els.tumor = new THREE.Mesh(new THREE.SphereGeometry(0.85, 40, 28), tumorMat);
        els.tumor.position.set(0.3, 0.1, 0.2);
        els.tumor.userData = { name: 'tumor', revealed: true, isTumor: true };
        internalGroup.add(els.tumor);
        els.internals.push(els.tumor);

        els.tumorGlow = new THREE.Mesh(
          new THREE.SphereGeometry(1.3, 24, 16),
          new THREE.MeshPhongMaterial({ color:0xff2200, transparent:true, opacity:0.22, emissive:0xff0000, side:THREE.BackSide })
        );
        els.tumorGlow.position.copy(els.tumor.position);
        internalGroup.add(els.tumorGlow);

        // Progress Ring
        const ringGeo = new THREE.TorusGeometry(1.0, 0.06, 8, 64);
        const ringMat = new THREE.MeshPhongMaterial({ color:0xffaa00, emissive:0x664400 });
        els.progressRing = new THREE.Mesh(ringGeo, ringMat);
        els.progressRing.position.copy(els.tumor.position);
        els.progressRing.visible = false;
        internalGroup.add(els.progressRing);

        // Ensure this entity is raycastable by adding class "cuttable"
        this.el.classList.add('cuttable');
      },

      tick: function(t, dt) {
        const time = t / 1000;
        
        // Pulse Tumor
        if (!state.tumorResected && state.tumorOn && els.tumorGlow) {
          els.tumorGlow.scale.setScalar(1 + 0.15*Math.sin(time*3.8));
          els.tumor.material.emissive.setHex(Math.sin(time*3.8) > 0 ? 0xcc0000 : 0x880000);
        }

        // Rotate ring
        if (els.progressRing && els.progressRing.visible) {
          els.progressRing.rotation.z = time * 2;
        }

        // Blood Physics
        els.wounds.forEach(m => {
          if (!m.userData.isBlood) return;
          m.userData.life -= 0.016;
          m.position.y += m.userData.vy;
          if (m.userData.life <= 0) m.visible = false;
          else m.material.opacity = Math.min(1, m.userData.life);
        });

        // Flying animation
        if (state.tumorFlying) {
          state.flyTime += 0.025;
          const ft = Math.min(1.0, state.flyTime);
          
          const start = state.flyStart;
          const target = document.querySelector('#bowl-group').object3D.position.clone();
          target.y += 0.5;

          const worldStart = els.tumor.parent.localToWorld(start.clone());
          
          // Bezier in world space
          const mid = worldStart.clone().lerp(target, 0.5).add(new THREE.Vector3(0, 3, 0));
          
          const p0 = worldStart;
          const p1 = mid;
          const p2 = target;
          
          const pos = p0.clone().multiplyScalar((1-ft)*(1-ft))
            .add(p1.clone().multiplyScalar(2*(1-ft)*ft))
            .add(p2.clone().multiplyScalar(ft*ft));
          
          const localPos = els.tumor.parent.worldToLocal(pos.clone());
          els.tumor.position.copy(localPos);
          els.tumor.rotation.y = ft * Math.PI * 4;

          if (ft >= 1.0) {
            state.tumorFlying = false;
            state.tumorInBowl = true;
            els.tumor.scale.setScalar(0.7);
            document.getElementById('bowl-status').style.display = 'block';
            setTimeout(() => document.getElementById('bowl-status').style.display = 'none', 3000);
          }
        }
      }
    });

    // ‚îÄ‚îÄ‚îÄ HELPER: CUTTING LOGIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function spawnCut(point, normal, isTumor) {
      state.cutCount++;
      const ncutsEl = document.getElementById('ncuts');
      if(ncutsEl) ncutsEl.innerText = "Incisions: " + state.cutCount;

      const liverEl = document.getElementById('liver-container');
      const container = liverEl.object3D; // THREE.Group

      // Convert world point/normal to local space of container
      const localPoint = container.worldToLocal(point.clone());
      // Normal is direction, so transform direction inverse
      const inverseMat = new THREE.Matrix4().copy(container.matrixWorld).invert();
      const localNormal = normal.clone().transformDirection(inverseMat).normalize();

      // Create geometry
      const w = 0.5 + Math.random()*0.8;
      const h = 0.07 + Math.random()*0.18;
      const slit = new THREE.Mesh(
        new THREE.PlaneGeometry(w, h),
        new THREE.MeshPhongMaterial({ color: isTumor ? 0x220000 : 0x0a0000, side: THREE.DoubleSide })
      );
      slit.position.copy(localPoint).addScaledVector(localNormal, 0.012);
      slit.lookAt(localPoint.clone().add(localNormal));
      container.add(slit);
      els.wounds.push(slit);

      // Blood
      for(let i=0; i<8; i++) {
        const r = 0.022 + Math.random()*0.07;
        const drop = new THREE.Mesh(
          new THREE.SphereGeometry(r, 7, 6),
          new THREE.MeshPhongMaterial({ color: isTumor ? 0xaa0044 : 0x880000, transparent: true, opacity: 1 })
        );
        drop.position.copy(localPoint).add(new THREE.Vector3((Math.random()-.5)*.5, (Math.random()-.5)*.35, (Math.random()-.5)*.2));
        drop.userData.isBlood = true;
        drop.userData.vy = -(0.012 + Math.random()*.03);
        drop.userData.life = 1.2 + Math.random()*.8;
        container.add(drop);
        els.wounds.push(drop);
      }

      // Logic
      if (isTumor) {
        state.tumorCutCount++;
        const progress = state.tumorCutCount / state.cutsToResect;
        
        els.progressRing.visible = true;
        els.progressRing.scale.setScalar(1 + progress * 0.5);
        els.progressRing.material.color.setHSL(0.08 - progress*0.08, 1, 0.5);

        const tScale = 1.0 - progress * 0.15;
        els.tumor.scale.setScalar(tScale);
        els.tumorGlow.scale.setScalar(tScale);

        updateStatus(`‚úÇÔ∏è RESECTING: ${Math.round(progress*100)}%`, '#ff8800');

        if (state.tumorCutCount >= state.cutsToResect && !state.tumorResected) {
          completeResection();
        }
      } else {
        // Reveal internals
        els.internals.forEach(obj => {
          if (!obj.visible && obj.userData.name !== 'tumor' && obj.position.distanceTo(localPoint) < 4.0) {
            obj.visible = true;
            obj.userData.revealed = true;
          }
        });
        updateStatus("‚úÇÔ∏è CUTTING TISSUE", '#ff4444');
      }
    }

    function completeResection() {
      state.tumorResected = true;
      els.progressRing.visible = false;
      els.tumor.material.color.setHex(0xff4400);
      els.tumor.material.emissive.setHex(0xff6600);
      els.tumorGlow.material.opacity = 0.5;
      updateStatus("‚úÖ TUMOR RESECTED! EXTRACT NOW (Grip/B or Button)", '#ffaa00');
      document.getElementById('btn-extract').style.display = 'inline-block';
    }

    // ‚îÄ‚îÄ‚îÄ COMPONENT: VR CUTTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    AFRAME.registerComponent('vr-cutter', {
      init: function() {
        this.raycaster = this.el.components.raycaster;
        this.isCutting = false;
        this.lastPt = null;
        
        // Listeners for Meta Quest Controls
        // Trigger = Cut
        this.el.addEventListener('triggerdown', () => { this.isCutting = true; });
        this.el.addEventListener('triggerup', () => { 
          this.isCutting = false; 
          this.lastPt = null;
          updateStatus("Ready (VR)", "#44ff88");
        });

        // Grip or B Button = Extract
        const extract = () => extractTumorToBowl();
        this.el.addEventListener('gripdown', extract);
        this.el.addEventListener('bbuttondown', extract);

        // A Button = Show Arrow
        this.el.addEventListener('abuttondown', () => { 
          const arrow = document.getElementById('bowl-arrow');
          if(arrow) arrow.setAttribute('visible', true);
        });
        this.el.addEventListener('abuttonup', () => { 
          const arrow = document.getElementById('bowl-arrow');
          if(arrow && state.tumorInBowl) arrow.setAttribute('visible', false);
        });
      },

      tick: function() {
        if (!this.isCutting) return;

        // Get intersection from raycaster
        const hits = this.raycaster.getIntersection(document.getElementById('liver-container'));
        
        if (hits) {
          const pt = hits.point;
          const object = hits.object; // The THREE mesh hit
          
          let isTumor = false;
          // Traverse up to find if we hit the tumor mesh specifically
          // Note: object is the specific mesh (lobe or tumor) inside the liver-container entity
          if (object.userData.isTumor || (object.userData.name === 'tumor')) {
            isTumor = true;
          }

          // Distance check
          if (!this.lastPt || pt.distanceTo(this.lastPt) > 0.08) {
            spawnCut(pt, hits.face.normal, isTumor);
            this.lastPt = pt.clone();
            
            // Haptic feedback
            const gp = this.el.components['tracked-controls'].controller;
            if (gp && gp.pulse) gp.pulse(0.5, 10);
          }
        }
      }
    });

    // ‚îÄ‚îÄ‚îÄ COMPONENT: DESKTOP CUTTER (MOUSE) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    AFRAME.registerComponent('desktop-cutter', {
      init: function() {
        this.isCutting = false;
        this.lastPt = null;
        
        // A-Frame cursor events
        this.el.sceneEl.addEventListener('mousedown', (e) => {
          // Right click = 2
          if (e.button === 2) {
            this.isCutting = true;
            // Disable look-controls to allow dragging without spinning camera
            const cam = document.querySelector('[look-controls]');
            if(cam) cam.setAttribute('look-controls', 'enabled', false);
          }
        });

        this.el.sceneEl.addEventListener('mouseup', (e) => {
          if (e.button === 2) {
            this.isCutting = false;
            this.lastPt = null;
            const cam = document.querySelector('[look-controls]');
            if(cam) cam.setAttribute('look-controls', 'enabled', true);
            updateStatus("Ready", "#44ff88");
          }
        });
        
        // Prevent context menu
        window.addEventListener('contextmenu', e => e.preventDefault());
      },
      
      tick: function() {
        if (!this.isCutting) return;
        
        // Raycast from mouse
        const raycaster = this.el.components.raycaster;
        const intersections = raycaster.intersections;

        if (intersections && intersections.length > 0) {
          // Filter for liver-container
          const hit = intersections.find(i => i.object.userData.isLiver || i.object.userData.isTumor);
          
          if (hit) {
            const isTumor = hit.object.userData.isTumor === true;
            
            if (!this.lastPt || hit.point.distanceTo(this.lastPt) > 0.08) {
              spawnCut(hit.point, hit.face.normal, isTumor);
              this.lastPt = hit.point.clone();
            }
          }
        }
      }
    });

    // ‚îÄ‚îÄ‚îÄ UI ACTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    window.toggleTumor = function() {
      state.tumorOn = !state.tumorOn;
      if (!state.tumorResected) {
        els.tumor.visible = state.tumorOn;
        els.tumorGlow.visible = state.tumorOn;
      }
      document.getElementById('btn-t').style.color = state.tumorOn ? '#ff4444' : '#666';
      updateStatus(state.tumorOn ? "Tumor Visible" : "Tumor Hidden");
    };

    window.toggleNerves = function() {
      state.nervesOn = !state.nervesOn;
      els.internals.forEach(o => {
        if(o.userData.name === 'nerve' && o.userData.revealed) o.visible = state.nervesOn;
      });
    };

    window.toggleVessels = function() {
      state.vesselsOn = !state.vesselsOn;
      els.internals.forEach(o => {
        if(['artery','portal','bile','hepaticV'].includes(o.userData.name) && o.userData.revealed) {
          o.visible = state.vesselsOn;
        }
      });
    };

    window.extractTumorToBowl = function() {
      if (!state.tumorResected) {
        updateStatus("‚ö†Ô∏è Cut tumor fully first!", "#ffaa00");
        return;
      }
      if (state.tumorInBowl) return;

      state.tumorFlying = true;
      state.flyStart = els.tumor.position.clone(); // Local pos
      state.flyTime = 0;
      
      els.tumorGlow.visible = false;
      document.getElementById('btn-extract').style.display = 'none';
      updateStatus("EXTRACTING...", "#44aaff");
      
      // Add cavity wound
      const cavity = new THREE.Mesh(
        new THREE.SphereGeometry(0.7, 24, 16),
        new THREE.MeshPhongMaterial({ color:0x110000, transparent:true, opacity:0.85 })
      );
      cavity.position.copy(els.tumor.position);
      els.liverGroup.object3D.add(cavity);
      els.wounds.push(cavity);
    };

    window.resetAll = function() {
      // Clear wounds
      els.wounds.forEach(m => m.parent.remove(m));
      els.wounds = [];
      
      // Reset State
      state.cutCount = 0;
      state.tumorCutCount = 0;
      state.tumorResected = false;
      state.tumorInBowl = false;
      state.tumorFlying = false;
      
      const ncutsEl = document.getElementById('ncuts');
      if(ncutsEl) ncutsEl.innerText = "Incisions: 0";
      
      // Reset Visuals
      els.internals.forEach(o => {
        if(o.userData.isTumor) {
          o.visible = true;
          o.scale.set(1,1,1);
          o.position.set(0.3, 0.1, 0.2);
          o.material.color.setHex(0xff0000);
          o.material.emissive.setHex(0xaa0000);
        } else if (o === els.tumorGlow) {
          o.visible = true;
          o.scale.set(1,1,1);
          o.position.copy(els.tumor.position);
          o.material.opacity = 0.22;
        } else {
          o.visible = false;
          o.userData.revealed = false;
        }
      });
      
      if(els.progressRing) els.progressRing.visible = false;
      
      document.getElementById('btn-extract').style.display = 'none';
      updateStatus("Reset Complete");
    };

    // Keyboard Shortcuts
    document.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      if(k==='t') toggleTumor();
      if(k==='n') toggleNerves();
      if(k==='v') toggleVessels();
      if(k==='r') resetAll();
      if(k==='e') extractTumorToBowl();
    });
  </script>
</head>
<body>

  <!-- 2D UI Overlay -->
  <div id="info">
    <h3>üî™ LIVER SURGICAL SIMULATOR</h3>
    <span>LEFT DRAG</span> ‚Üí Rotate Camera<br>
    <span>RIGHT DRAG</span> ‚Üí ‚úÇÔ∏è Cut<br>
    <span>SCROLL</span> ‚Üí Zoom<br>
    <div id="vrinfo">
      ü•Ω <b>VR CONTROLS:</b><br>
      Right Trigger = Cut<br>
      Right Grip/B = Extract<br>
      Right A = Show Arrow
    </div>
    <div id="status-text">Ready ‚Äî right-drag to cut</div>
    <div id="ncuts">Incisions: 0</div>
  </div>

  <div id="legend">
    <h3>ANATOMY</h3>
    <div><span class="dot" style="background:#ff2222"></span>Hepatic Artery</div>
    <div><span class="dot" style="background:#dd22aa"></span>Portal Vein</div>
    <div><span class="dot" style="background:#aadd00"></span>Bile Duct</div>
    <div><span class="dot" style="background:#2244ff"></span>Hepatic Vein</div>
    <div><span class="dot" style="background:#ffee00"></span>Nerve</div>
    <div><span class="dot" style="background:#00ffff"></span>Lymphatic</div>
    <div><span class="dot" style="background:#ff0000;box-shadow:0 0 6px #f00"></span>TUMOR</div>
  </div>

  <div id="bowl-status">ü•£ Tumor placed in specimen bowl!</div>

  <div id="bar">
    <button class="ui-btn" onclick="toggleTumor()" id="btn-t" style="border-color:#ff4444; color:#ff4444">üî¥ TUMOR</button>
    <button class="ui-btn" onclick="toggleNerves()">üíõ NERVES</button>
    <button class="ui-btn" onclick="toggleVessels()">ü©∏ VESSELS</button>
    <button class="ui-btn" onclick="resetAll()" style="border-color:#f55;color:#f88;">‚Ü∫ RESET</button>
  </div>

  <!-- A-FRAME SCENE -->
  <a-scene shadow="type: pcfsoft" renderer="antialias: true; colorManagement: true; exposure: 1.1">
    
    <!-- ASSETS (Programmatic generation handled in components) -->
    <a-asset-item id="liver-system"></a-asset-item>

    <!-- LIGHTS -->
    <a-entity light="type: ambient; color: #ffeedd; intensity: 1.0"></a-entity>
    <a-entity light="type: directional; color: #ffffff; intensity: 1.5; castShadow: true; shadowMapWidth: 2048; shadowMapHeight: 2048" position="0 5 20"></a-entity>
    <a-entity light="type: directional; color: #ffeedd; intensity: 0.8" position="20 20 20"></a-entity>
    <a-entity light="type: spot; color: #ffffff; intensity: 2.5; angle: 30; penumbra: 0.3; castShadow: true" position="0 15 5" target="#table-target"></a-entity>
    <a-entity id="table-target" position="0 0 0"></a-entity>

    <!-- CAMERA RIG -->
    <a-entity id="rig" position="0 1 12">
      <a-camera look-controls="enabled: true" wasd-controls="enabled: true" position="0 0 0">
        <!-- Desktop Cursor (Raycaster) attached to camera for Mouse Interaction -->
        <!-- We use a custom component 'desktop-cutter' to handle right-click drags -->
        <a-entity id="mouse-cursor" 
                  raycaster="objects: .cuttable; far: 100"
                  cursor="rayOrigin: mouse"
                  desktop-cutter>
        </a-entity>
        
        <!-- In-VR HUD Status Text -->
        <a-text id="vr-status" value="Ready" position="0 -0.4 -1" align="center" width="1.5" color="#44ff88" visible="false"></a-text>
      </a-camera>

      <!-- VR CONTROLLERS -->
      <a-entity id="leftHand" oculus-touch-controls="hand: left" laser-controls="hand: left" raycaster="objects: .ui-btn; far: 5"></a-entity>
      
      <a-entity id="rightHand" 
                oculus-touch-controls="hand: right" 
                vr-cutter
                raycaster="objects: .cuttable; showLine: true; far: 5; lineColor: #ff0000"
                line="color: #ff0000; opacity: 0.5">
          <!-- Scalpel Model attached to hand -->
          <a-entity id="vr-scalpel" position="0 0 -0.05" rotation="-90 0 0" visible="true">
             <a-cone color="#ddeeff" height="0.8" radius-bottom="0.035" position="0 0 0" rotation="180 0 0" material="metalness:0.8; roughness:0.2"></a-cone>
             <a-cylinder color="#999aaa" height="0.1" radius="0.055" position="0 0.45 0"></a-cylinder>
             <a-cylinder color="#221108" height="0.72" radius="0.03" position="0 0.86 0"></a-cylinder>
          </a-entity>
      </a-entity>
    </a-entity>

    <!-- ENVIRONMENT -->
    <a-plane position="0 -4 0" rotation="-90 0 0" width="80" height="80" color="#111820" shadow="receive: true"></a-plane>
    <a-box position="0 -3.5 0" width="22" height="0.3" depth="14" color="#1a3040" material="roughness: 0.4" shadow="receive: true"></a-box>
    <a-box position="0 -3.35 0" width="21.5" height="0.12" depth="13.5" color="#1a5c30" shadow="receive: true"></a-box>

    <!-- LIVER CONTAINER -->
    <a-entity id="liver-container" liver-generator position="0 2 0"></a-entity>

    <!-- SPECIMEN BOWL -->
    <a-entity id="bowl-group" position="6 -2.5 2">
      <a-cylinder height="1.0" radius="1.8" color="#cccccc" material="metalness: 0.4; roughness: 0.2" shadow="cast: true"></a-cylinder>
      <a-cylinder height="0.95" radius="1.6" color="#aaaaaa" position="0 0.02 0" side="back"></a-cylinder>
      <a-cylinder height="0.1" radius="1.1" color="#999999" position="0 -0.55 0"></a-cylinder>
      
      <!-- Arrow Indicator -->
      <a-cone id="bowl-arrow" color="#ffcc00" height="0.6" radius-bottom="0.2" position="0 2.5 0" material="emissive: #664400; emissiveIntensity: 0.5">
        <a-animation attribute="position" to="0 2.7 0" direction="alternate" dur="1000" repeat="indefinite"></a-animation>
      </a-cone>
      <a-text value="SPECIMEN" position="0 1.5 0" align="center" color="#ffcc00" look-at="#rig"></a-text>
    </a-entity>

  </a-scene>
</body>
</html>
