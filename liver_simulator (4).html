<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Liver Surgical Simulator â€” VR</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@300;500;700&display=swap');

* { margin:0; padding:0; box-sizing:border-box; }

body {
  background:#000;
  overflow:hidden;
  font-family:'Share Tech Mono', monospace;
  color:#fff;
}

canvas { display:block; }

/* â”€â”€ HUD â”€â”€ */
#hud {
  position:fixed; top:0; left:0; right:0; bottom:0;
  pointer-events:none; z-index:10;
}

/* Top bar */
#topbar {
  position:absolute; top:0; left:0; right:0;
  background:linear-gradient(180deg,rgba(0,0,0,0.85) 0%,transparent 100%);
  padding:14px 22px;
  display:flex; align-items:center; justify-content:space-between;
}
#topbar h1 {
  font-family:'Rajdhani',sans-serif;
  font-weight:700; font-size:20px;
  color:#ff4422; letter-spacing:3px;
  text-shadow:0 0 20px rgba(255,60,20,0.6);
}
#topbar .meta { font-size:11px; color:#888; letter-spacing:1px; }

/* Mode indicator */
#mode-badge {
  position:absolute; top:14px; left:50%; transform:translateX(-50%);
  background:rgba(0,0,0,0.8); border:1px solid #555;
  border-radius:20px; padding:5px 18px;
  font-size:12px; color:#ffdd00; letter-spacing:2px;
}

/* Status strip */
#status-strip {
  position:absolute; bottom:0; left:0; right:0;
  background:linear-gradient(0deg,rgba(0,0,0,0.9) 0%,transparent 100%);
  padding:14px 22px 18px;
  display:flex; align-items:flex-end; justify-content:space-between;
}
#status-text { font-size:13px; color:#44ff88; letter-spacing:1px; }
#cut-count   { font-size:11px; color:#ffaa00; margin-top:3px; }

/* Legend */
#legend {
  position:absolute; top:60px; right:16px;
  background:rgba(0,0,0,0.82); border:1px solid #2a2a3a;
  border-radius:10px; padding:14px 16px; width:190px;
  pointer-events:none;
}
#legend h3 {
  font-size:9px; color:#666; letter-spacing:3px;
  margin-bottom:10px; font-family:'Rajdhani',sans-serif;
}
.leg { display:flex; align-items:center; gap:8px; font-size:10px; color:#ccc; margin:5px 0; }
.dot { width:10px; height:10px; border-radius:50%; flex-shrink:0; }
.dot.pulse { animation: pulse 1.5s infinite; }
@keyframes pulse {
  0%,100%{ box-shadow:0 0 4px currentColor; }
  50%    { box-shadow:0 0 14px currentColor; }
}

/* Toolbar */
#toolbar {
  position:absolute; bottom:60px; left:50%; transform:translateX(-50%);
  display:flex; gap:6px; pointer-events:all;
}
.tool-btn {
  background:rgba(10,10,20,0.92);
  border:1px solid #333; color:#aaa;
  padding:8px 14px; border-radius:6px;
  cursor:pointer; font:11px 'Share Tech Mono',monospace;
  transition:all .2s; white-space:nowrap;
}
.tool-btn:hover { background:rgba(60,60,90,.9); border-color:#888; color:#fff; }
.tool-btn.active { border-color:#44ff88; color:#44ff88; background:rgba(0,40,20,.5); }
.tool-btn.danger { border-color:#ff4444; color:#ff8888; }
.tool-btn.vr     { border-color:#aa44ff; color:#cc88ff; background:rgba(30,0,50,.5); }
.tool-btn.tumor  { border-color:#ff2222; color:#ff6666; }

/* VR hint */
#vr-hint {
  position:absolute; bottom:110px; left:50%; transform:translateX(-50%);
  background:rgba(100,0,200,0.25); border:1px solid #aa44ff;
  border-radius:8px; padding:8px 20px;
  font-size:11px; color:#cc88ff; text-align:center;
  opacity:0; transition:opacity .4s; pointer-events:none;
}

/* Crosshair */
#xhair {
  position:absolute; top:50%; left:50%;
  transform:translate(-50%,-50%);
  width:28px; height:28px; pointer-events:none;
  opacity:0; transition:opacity .2s;
}
#xhair::before,#xhair::after {
  content:''; position:absolute; background:rgba(255,80,40,0.9);
}
#xhair::before { width:100%; height:2px; top:50%; transform:translateY(-50%); }
#xhair::after  { height:100%; width:2px; left:50%; transform:translateX(-50%); }
#xhair.show { opacity:1; }

/* Phase overlay */
#phase-overlay {
  position:absolute; inset:0;
  display:flex; flex-direction:column;
  align-items:center; justify-content:center;
  background:rgba(0,0,0,0.92);
  z-index:20; transition:opacity .5s;
}
#phase-overlay h2 {
  font-family:'Rajdhani',sans-serif; font-size:36px;
  color:#ff4422; letter-spacing:4px; margin-bottom:16px;
  text-shadow:0 0 30px rgba(255,60,20,.7);
}
#phase-overlay p  { color:#aaa; font-size:14px; line-height:2; text-align:center; }
#phase-overlay b  { color:#ffdd00; }
#start-btn {
  margin-top:28px; padding:13px 40px;
  background:transparent; border:2px solid #ff4422;
  color:#ff4422; font:700 16px 'Rajdhani',sans-serif;
  letter-spacing:3px; cursor:pointer; border-radius:6px;
  transition:all .2s;
}
#start-btn:hover { background:#ff4422; color:#000; }

/* Tumor extracted */
#extracted {
  position:absolute; top:50%; left:50%;
  transform:translate(-50%,-50%) scale(0);
  background:rgba(0,0,0,0.95); border:2px solid #ff2222;
  border-radius:12px; padding:28px 40px; text-align:center;
  z-index:30; transition:transform .4s cubic-bezier(.34,1.56,.64,1);
}
#extracted.show { transform:translate(-50%,-50%) scale(1); }
#extracted h2 { color:#ff2222; font-family:'Rajdhani',sans-serif; font-size:28px; letter-spacing:3px; margin-bottom:8px; }
#extracted p  { color:#aaa; font-size:12px; }
#extracted .close-btn {
  margin-top:16px; padding:8px 24px;
  background:#ff2222; border:none; color:#fff;
  font:12px 'Share Tech Mono',monospace; cursor:pointer; border-radius:4px;
}
</style>
</head>
<body>

<!-- Phase overlay / start screen -->
<div id="phase-overlay">
  <h2>ğŸ”¬ LIVER SURGICAL SIMULATOR</h2>
  <p>
    <b>LEFT DRAG</b> â†’ Rotate camera &nbsp;|&nbsp; <b>SCROLL</b> â†’ Zoom<br>
    <b>RIGHT DRAG on liver</b> â†’ âœ‚ï¸ CUT open the liver<br>
    <b>RIGHT DRAG on tumor</b> â†’ ğŸ”ª CUT &amp; extract tumor<br>
    <b>T</b> â†’ Reveal tumor &nbsp;|&nbsp; <b>R</b> â†’ Reset<br><br>
    <span style="color:#aa44ff">Click <b style="color:#cc88ff">ENTER VR</b> for WebXR immersive mode (needs VR headset)</span>
  </p>
  <button id="start-btn" onclick="startSim()">â–¶ START SIMULATION</button>
</div>

<!-- Extracted tumor popup -->
<div id="extracted">
  <h2>ğŸ”´ TUMOR EXTRACTED</h2>
  <p>Malignant hepatocellular carcinoma<br>
  Mass: ~42g &nbsp;|&nbsp; Stage: II<br>
  Margins: Clear âœ“</p>
  <button class="close-btn" onclick="closeExtracted()">CONTINUE</button>
</div>

<!-- HUD -->
<div id="hud">
  <div id="topbar">
    <h1>âš• HEPATIC SURGICAL SIM</h1>
    <div class="meta">WebXR â€¢ Three.js â€¢ v3.0</div>
  </div>

  <div id="mode-badge">MODE: EXPLORATION</div>

  <div id="legend">
    <h3>ANATOMY</h3>
    <div class="leg"><div class="dot" style="background:#ff2222"></div>Hepatic Artery</div>
    <div class="leg"><div class="dot" style="background:#dd22bb"></div>Portal Vein</div>
    <div class="leg"><div class="dot" style="background:#aadd11"></div>Bile Duct</div>
    <div class="leg"><div class="dot" style="background:#2244ff"></div>Hepatic Vein</div>
    <div class="leg"><div class="dot" style="background:#ffee00"></div>Nerve Plexus</div>
    <div class="leg"><div class="dot" style="background:#00ffff"></div>Lymphatic</div>
    <div class="leg"><div class="dot" style="background:#44aa22"></div>Gallbladder</div>
    <div class="leg">
      <div class="dot pulse" style="background:#ff0000;color:#ff0000"></div>
      TUMOR (malignant)
    </div>
  </div>

  <div id="status-strip">
    <div>
      <div id="status-text">Ready â€” right-drag on the liver to cut</div>
      <div id="cut-count">Incisions: 0</div>
    </div>
  </div>

  <div id="xhair"></div>

  <div id="vr-hint">ğŸ¥½ VR mode active â€” use controller trigger to cut</div>

  <div id="toolbar">
    <button class="tool-btn tumor" onclick="toggleTumor()" id="btn-tumor">ğŸ”´ TUMOR</button>
    <button class="tool-btn active" id="btn-n" onclick="toggleNerves()">ğŸ’› NERVES</button>
    <button class="tool-btn active" id="btn-v" onclick="toggleVessels()">ğŸ©¸ VESSELS</button>
    <button class="tool-btn danger" onclick="resetAll()">â†º RESET</button>
    <button class="tool-btn vr" id="btn-vr" onclick="enterVR()">ğŸ¥½ ENTER VR</button>
  </div>
</div>

<!-- Three.js + WebXR -->
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/webxr/VRButton.js"></script>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDERER â€” WebXR enabled
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type    = THREE.PCFSoftShadowMap;
renderer.xr.enabled        = true;   // â† WebXR
renderer.setClearColor(0x0d0f1a, 1);
document.body.appendChild(renderer.domElement);

// â”€â”€â”€ Scene â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const scene  = new THREE.Scene();
scene.background = new THREE.Color(0x0d0f1a);

const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.01, 500);
camera.position.set(0, 2, 20);
camera.lookAt(0, 0, 0);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.minDistance   = 4;
controls.maxDistance   = 55;
controls.mouseButtons  = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: null };

// â”€â”€â”€ Lights â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
scene.add(new THREE.AmbientLight(0xffffff, 2.2));

const sun = new THREE.DirectionalLight(0xffffff, 3.5);
sun.position.set(5, 20, 15);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
scene.add(sun);

const front = new THREE.DirectionalLight(0xffeedd, 2.0);
front.position.set(0, 0, 25);
scene.add(front);

const fill = new THREE.DirectionalLight(0xffffff, 1.2);
fill.position.set(-15, 5, -8);
scene.add(fill);

const bot = new THREE.DirectionalLight(0xffffff, 0.8);
bot.position.set(0, -15, 5);
scene.add(bot);

// Surgical lamp
const lamp = new THREE.SpotLight(0xfff5e0, 4.0, 40, Math.PI/5, 0.3);
lamp.position.set(0, 20, 2);
lamp.castShadow = true;
scene.add(lamp); scene.add(lamp.target);

// â”€â”€â”€ Environment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(80, 80),
  new THREE.MeshPhongMaterial({ color: 0x1a2e20 })
);
floor.rotation.x = -Math.PI/2;
floor.position.y = -8;
floor.receiveShadow = true;
scene.add(floor);

const grid = new THREE.GridHelper(80, 50, 0x0d1f14, 0x0d1f14);
grid.position.y = -7.98;
scene.add(grid);

// Table
scene.add(Object.assign(new THREE.Mesh(
  new THREE.BoxGeometry(22, 0.3, 12),
  new THREE.MeshPhongMaterial({ color: 0x152535 })
), { position: new THREE.Vector3(0, -7.2, 0) }));

scene.add(Object.assign(new THREE.Mesh(
  new THREE.BoxGeometry(21.5, 0.12, 11.5),
  new THREE.MeshPhongMaterial({ color: 0x1e5530 })
), { position: new THREE.Vector3(0, -7.04, 0) }));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LIVER â€” 5 lobes, bright vivid red-orange
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const liverGroup  = new THREE.Group();
scene.add(liverGroup);
const liverMeshes = [];

function makeLiverMat() {
  return new THREE.MeshPhongMaterial({
    color:    0xcc3300,
    specular: 0x441100,
    shininess: 35,
    side: THREE.DoubleSide,
  });
}

function addLobe(x, y, z,  rx, ry, rz,  seg=72) {
  const geo = new THREE.SphereGeometry(1, seg, Math.floor(seg/2));
  const pos = geo.attributes.position;
  for (let i = 0; i < pos.count; i++) {
    let vx = pos.getX(i), vy = pos.getY(i), vz = pos.getZ(i);
    if (vy < 0) vy *= 0.68;
    if (vy > 0.4 && vz < -0.2) vy *= 0.88;
    const n = 0.035 * (Math.sin(vx*9+vy*7)*Math.cos(vz*11));
    pos.setXYZ(i, vx+n, vy+n*.5, vz+n);
  }
  geo.computeVertexNormals();
  const m = new THREE.Mesh(geo, makeLiverMat());
  m.scale.set(rx, ry, rz);
  m.position.set(x, y, z);
  m.castShadow = m.receiveShadow = true;
  m.userData.isLiver = true;
  liverGroup.add(m);
  liverMeshes.push(m);
  return m;
}

addLobe(  0.0,  0.0,  0.0,  4.8, 2.8, 3.6, 80);
addLobe(  3.0, -0.2,  0.3,  3.2, 2.3, 3.2, 64);
addLobe( -2.5,  0.3,  0.0,  2.4, 2.0, 2.8, 64);
addLobe(  0.5,  1.8, -0.7,  1.3, 0.75, 1.0, 48);
addLobe(  1.0, -1.4,  1.1,  1.1, 0.75, 0.9, 40);

// Gallbladder
const gb = new THREE.Mesh(
  new THREE.SphereGeometry(0.58, 24, 16),
  new THREE.MeshPhongMaterial({ color:0x448820, shininess:50 })
);
gb.scale.set(1, 1.5, 1);
gb.position.set(2.9, -2.4, 1.3);
gb.castShadow = true;
scene.add(gb);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TUMOR â€” large glowing red sphere INSIDE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const tumorMat = new THREE.MeshPhongMaterial({
  color: 0xff0000, emissive: 0xaa0000, shininess: 80,
});
const tumor = new THREE.Mesh(new THREE.SphereGeometry(0.92, 48, 32), tumorMat);
tumor.position.set(0.3, 0.1, 0.2);
tumor.visible = false;
tumor.userData = { name:'tumor', revealed:false, extracted:false };
scene.add(tumor);

const tumorGlowMat = new THREE.MeshPhongMaterial({
  color:0xff2200, emissive:0xff0000,
  transparent:true, opacity:0.3, side:THREE.BackSide,
});
const tumorGlow = new THREE.Mesh(new THREE.SphereGeometry(1.35, 24, 16), tumorGlowMat);
tumorGlow.position.copy(tumor.position);
tumorGlow.visible = false;
scene.add(tumorGlow);

// â”€â”€â”€ Tumor cut tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let tumorCutPoints = 0;
const TUMOR_CUTS_NEEDED = 8;   // cuts needed to extract
let tumorExtracted = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INTERNAL ANATOMY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const internalGroup = new THREE.Group();
scene.add(internalGroup);
const allInternals  = [];

function iTube(ax,ay,az, bx,by,bz, r, hex, name) {
  const A = new THREE.Vector3(ax,ay,az);
  const B = new THREE.Vector3(bx,by,bz);
  const mid = A.clone().add(B).multiplyScalar(0.5);
  const len = A.distanceTo(B);
  const m = new THREE.Mesh(
    new THREE.CylinderGeometry(r, r*.85, len, 12),
    new THREE.MeshPhongMaterial({ color:hex, shininess:45 })
  );
  m.position.copy(mid);
  m.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), B.clone().sub(A).normalize());
  m.castShadow = true;
  m.visible = false;
  m.userData = { name, revealed:false };
  internalGroup.add(m); allInternals.push(m);
}

function iBlob(x,y,z, r, hex, name) {
  const m = new THREE.Mesh(
    new THREE.SphereGeometry(r, 18, 12),
    new THREE.MeshPhongMaterial({ color:hex, shininess:35 })
  );
  m.position.set(x,y,z);
  m.visible = false;
  m.userData = { name, revealed:false };
  internalGroup.add(m); allInternals.push(m);
}

// Hepatic Artery (red)
iTube(  0,-2.5, .4,  0,2.5, .4,  .18,0xff2222,'artery');
iTube(  0,  .5, .4,  3.2,.9,.5,  .12,0xff2222,'artery');
iTube(  0,  .5, .4, -3.0,.8,.5,  .11,0xff2222,'artery');
iTube(3.2, .9, .5,  4.2, 0,.6,  .09,0xff2222,'artery');
// Portal Vein (purple)
iTube(  0,-2.0,  0,  0,  .8,  0,  .32,0xdd22bb,'portal');
iTube(  0,   0,  0,  3.0,.5, .1,  .24,0xdd22bb,'portal');
iTube(  0,   0,  0, -2.8,.4, .1,  .20,0xdd22bb,'portal');
// Bile Ducts (yellow-green)
iTube(-.1,2.0,-.6, -.1,-1.5,-.6,  .10,0xaadd00,'bile');
iTube(-.1, .6,-.6,  2.8,.9,-.5,  .08,0xaadd00,'bile');
iTube(-.1, .6,-.6, -2.6,.8,-.5,  .07,0xaadd00,'bile');
// Hepatic Veins (blue)
iTube( .2,2.8,-.7,  .2,-1.5,-.3,  .26,0x2244ff,'hepaticV');
iTube(2.2,2.2,-.6,  .2,  .7,-.4,  .18,0x2244ff,'hepaticV');
iTube(-2.0,2.1,-.6, .2,  .7,-.4,  .16,0x2244ff,'hepaticV');
// Nerves (yellow)
iTube( .7,1.5,1.9,  .7,-1.5,1.9,  .045,0xffee00,'nerve');
iTube(-.6,1.3,2.0, -.6,-1.3,2.0,  .038,0xffee00,'nerve');
iTube(1.8, .8,1.4,  1.8,-1.0,1.4, .032,0xffee00,'nerve');
iTube(-1.6,.9,1.5, -1.6,-1.0,1.5, .032,0xffee00,'nerve');
// Lymphatics (cyan)
iTube(1.4,1.5,-1.6,  1.4,-.8,-1.6,  .065,0x00ffff,'lymph');
iTube(-1.2,1.4,-1.6,-1.2,-.7,-1.6,  .055,0x00ffff,'lymph');
// Sinusoids
for(let i=0;i<24;i++) {
  iBlob((Math.random()-.5)*6.5,(Math.random()-.5)*4.5,(Math.random()-.5)*4.0,
    .05+Math.random()*.14,0xdd2222,'sinusoid');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SCALPEL MESH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const scalpel = new THREE.Group();
scene.add(scalpel);

const _blade = new THREE.Mesh(
  new THREE.ConeGeometry(0.035, 0.82, 8),
  new THREE.MeshPhongMaterial({ color:0xdde8ff, specular:0xffffff, shininess:200 })
);
_blade.rotation.x = Math.PI;
scalpel.add(_blade);

const _guard = new THREE.Mesh(
  new THREE.CylinderGeometry(0.055, 0.055, 0.09, 8),
  new THREE.MeshPhongMaterial({ color:0x9999aa })
);
_guard.position.y = 0.45; scalpel.add(_guard);

const _handle = new THREE.Mesh(
  new THREE.CylinderGeometry(0.03, 0.038, 0.72, 10),
  new THREE.MeshPhongMaterial({ color:0x221108 })
);
_handle.position.y = 0.85; scalpel.add(_handle);
scalpel.visible = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VR CONTROLLERS  (when in VR mode)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const controller1 = renderer.xr.getController(0);
const controller2 = renderer.xr.getController(1);
scene.add(controller1); scene.add(controller2);

// Controller visual (ray line)
function makeControllerRay() {
  const geo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)
  ]);
  const mat = new THREE.LineBasicMaterial({ color:0xff4422, linewidth:2 });
  return new THREE.Line(geo, mat);
}
controller1.add(makeControllerRay());
controller2.add(makeControllerRay());

// VR scalpel attached to right controller
const vrScalpel = scalpel.clone();
vrScalpel.scale.setScalar(0.4);
controller2.add(vrScalpel);
vrScalpel.visible = true;

// VR squeeze = cut
controller1.addEventListener('selectstart', () => vrCut(controller1));
controller2.addEventListener('selectstart', () => vrCut(controller2));

const vrRaycaster = new THREE.Raycaster();
function vrCut(ctrl) {
  const pos = new THREE.Vector3();
  const dir = new THREE.Vector3();
  ctrl.getWorldPosition(pos);
  ctrl.getWorldDirection(dir);
  vrRaycaster.set(pos, dir.negate());
  const allTargets = [...liverMeshes, ...(tumor.visible ? [tumor] : [])];
  const hits = vrRaycaster.intersectObjects(allTargets, false);
  if (hits.length > 0) {
    const h   = hits[0];
    const nrm = h.face.normal.clone().transformDirection(h.object.matrixWorld).normalize();
    if (h.object === tumor) { cutTumor(h.point.clone(), nrm); }
    else                    { spawnCut(h.point.clone(), nrm); }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CUT SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const raycaster  = new THREE.Raycaster();
const mouse2D    = new THREE.Vector2();
const wounds     = [];
let   cutCount   = 0;
let   rightDown  = false;
let   lastPt     = null;
let   onLiver    = false;
let   onTumor    = false;

const REVEAL_R  = 4.2;
const MIN_DIST  = 0.08;

const statusEl  = document.getElementById('status-text');
const ncutsEl   = document.getElementById('cut-count');
const modeBadge = document.getElementById('mode-badge');
const xhair     = document.getElementById('xhair');

function setStatus(txt, col='#44ff88') {
  statusEl.textContent = txt;
  statusEl.style.color = col;
}
function setMode(txt) { modeBadge.textContent = 'MODE: ' + txt; }

function revealNear(pt) {
  allInternals.forEach(obj => {
    if (!obj.visible && obj.position.distanceTo(pt) < REVEAL_R) {
      obj.visible = true;
      obj.userData.revealed = true;
    }
  });
}

// â”€â”€ Wound on liver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnCut(pt, nrm) {
  cutCount++;
  ncutsEl.textContent = 'Incisions: ' + cutCount;

  const w = 0.55 + Math.random()*.75;
  const h = 0.08 + Math.random()*.18;

  // Outer wound
  const s1 = new THREE.Mesh(
    new THREE.PlaneGeometry(w, h),
    new THREE.MeshPhongMaterial({ color:0x0a0000, side:THREE.DoubleSide })
  );
  s1.position.copy(pt).addScaledVector(nrm, 0.012);
  s1.lookAt(pt.clone().add(nrm));
  scene.add(s1); wounds.push(s1);

  // Inner
  const s2 = new THREE.Mesh(
    new THREE.PlaneGeometry(w*.45, h*.4),
    new THREE.MeshPhongMaterial({ color:0x000000, side:THREE.DoubleSide })
  );
  s2.position.copy(pt).addScaledVector(nrm, 0.018);
  s2.lookAt(pt.clone().add(nrm));
  scene.add(s2); wounds.push(s2);

  // Blood drops
  for (let i=0; i<12; i++) {
    const r    = 0.022 + Math.random()*.072;
    const drop = new THREE.Mesh(
      new THREE.SphereGeometry(r, 7, 6),
      new THREE.MeshPhongMaterial({ color:0x880000, transparent:true, opacity:1 })
    );
    drop.position.copy(pt).add(new THREE.Vector3(
      (Math.random()-.5)*.55, (Math.random()-.5)*.38, (Math.random()-.5)*.22
    ));
    drop.userData.isBlood = true;
    drop.userData.vy      = -(0.013 + Math.random()*.032);
    drop.userData.life    = 1.2 + Math.random()*.9;
    scene.add(drop); wounds.push(drop);
  }

  revealNear(pt);
}

// â”€â”€ Tumor cutting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function cutTumor(pt, nrm) {
  tumorCutPoints++;
  setStatus(`Cutting tumor... ${tumorCutPoints}/${TUMOR_CUTS_NEEDED} cuts`, '#ff8844');
  setMode('TUMOR EXCISION');

  // Wound on tumor surface
  const sc = 0.25 + Math.random()*.35;
  const tw = new THREE.Mesh(
    new THREE.PlaneGeometry(sc, sc*.35),
    new THREE.MeshPhongMaterial({ color:0x220000, side:THREE.DoubleSide })
  );
  tw.position.copy(pt).addScaledVector(nrm, 0.015);
  tw.lookAt(pt.clone().add(nrm));
  scene.add(tw); wounds.push(tw);

  // Blood from tumor
  for (let i=0; i<8; i++) {
    const drop = new THREE.Mesh(
      new THREE.SphereGeometry(0.03+Math.random()*.06, 6, 5),
      new THREE.MeshPhongMaterial({ color:0xcc0000, transparent:true, opacity:1 })
    );
    drop.position.copy(pt).add(new THREE.Vector3(
      (Math.random()-.5)*.4, (Math.random()-.5)*.3, (Math.random()-.5)*.15
    ));
    drop.userData.isBlood = true;
    drop.userData.vy      = -(0.015 + Math.random()*.03);
    drop.userData.life    = 1.5;
    scene.add(drop); wounds.push(drop);
  }

  // Enough cuts â€” extract!
  if (tumorCutPoints >= TUMOR_CUTS_NEEDED && !tumorExtracted) {
    extractTumor();
  }
}

function extractTumor() {
  tumorExtracted = true;
  setMode('EXTRACTION');
  setStatus('ğŸ”´ TUMOR EXTRACTED SUCCESSFULLY', '#ff4444');

  // Animate tumor flying out
  const startPos = tumor.position.clone();
  const endPos   = new THREE.Vector3(8, 6, 5);
  let   t0       = 0;

  function animExtract() {
    t0 += 0.025;
    const ease = t0 < 1 ? t0*t0*(3-2*t0) : 1;
    tumor.position.lerpVectors(startPos, endPos, ease);
    tumorGlow.position.copy(tumor.position);
    tumor.rotation.y     += 0.05;
    tumor.rotation.x     += 0.03;
    tumorGlow.rotation.y  = tumor.rotation.y;
    tumor.scale.setScalar(1 - ease*0.5 + 0.5);

    if (ease < 1) { requestAnimationFrame(animExtract); }
    else {
      tumor.visible     = false;
      tumorGlow.visible = false;
      document.getElementById('extracted').classList.add('show');
    }
  }
  animExtract();
}

function closeExtracted() {
  document.getElementById('extracted').classList.remove('show');
  setMode('POST-OP');
  setStatus('Tumor extracted. Procedure complete.', '#44ff88');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MOUSE EVENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
renderer.domElement.addEventListener('mousemove', e => {
  mouse2D.x =  (e.clientX/innerWidth)*2 - 1;
  mouse2D.y = -(e.clientY/innerHeight)*2 + 1;

  raycaster.setFromCamera(mouse2D, camera);

  // Check tumor first (higher priority)
  const allTargets = [...liverMeshes];
  if (tumor.visible && !tumorExtracted) allTargets.unshift(tumor);

  const hits = raycaster.intersectObjects(allTargets, false);

  if (hits.length > 0) {
    const h   = hits[0];
    const nrm = h.face.normal.clone().transformDirection(h.object.matrixWorld).normalize();

    onLiver = h.object !== tumor;
    onTumor = h.object === tumor;

    scalpel.visible = true;
    document.body.style.cursor = 'none';

    scalpel.position.copy(h.point).addScaledVector(nrm, 0.65);
    scalpel.lookAt(h.point.clone().add(nrm));
    scalpel.rotateX(-Math.PI/2);

    if (rightDown) {
      xhair.classList.add('show');
      if (!lastPt) {
        lastPt = h.point.clone();
        if (onTumor) { cutTumor(h.point.clone(), nrm); }
        else         { spawnCut(h.point.clone(), nrm); }
      } else if (h.point.distanceTo(lastPt) > MIN_DIST) {
        if (onTumor) { cutTumor(h.point.clone(), nrm); }
        else         { spawnCut(h.point.clone(), nrm); }
        lastPt = h.point.clone();
      }
    }
  } else {
    onLiver = onTumor = false;
    scalpel.visible = false;
    document.body.style.cursor = 'default';
    if (rightDown) lastPt = null;
  }
});

renderer.domElement.addEventListener('mousedown', e => {
  if (e.button === 2) {
    rightDown = true;
    controls.enabled = false;
    if (onTumor)      { setStatus('ğŸ”ª CUTTING TUMOR â€” drag around it!', '#ff4444'); setMode('TUMOR EXCISION'); }
    else if (onLiver) { setStatus('âœ‚ï¸ CUTTING â€” drag across liver!', '#ff8844'); setMode('INCISION'); }
    else              { setStatus('âš ï¸ Hover over the liver or tumor first!', '#ffaa00'); }
  }
});

renderer.domElement.addEventListener('mouseup', e => {
  if (e.button === 2) {
    rightDown = false;
    lastPt = null;
    controls.enabled = true;
    xhair.classList.remove('show');
    if (!tumorExtracted) {
      setStatus('Ready â€” right-drag on liver to cut | on tumor to excise');
      setMode('EXPLORATION');
    }
  }
});

renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  KEYBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let tumorVisible=false, nervesOn=true, vesselsOn=true;

document.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  if (k==='t') toggleTumor();
  if (k==='n') toggleNerves();
  if (k==='v') toggleVessels();
  if (k==='r') resetAll();
});

function toggleTumor() {
  if (tumorExtracted) return;
  tumorVisible = !tumorVisible;
  tumor.visible     = tumorVisible;
  tumorGlow.visible = tumorVisible;
  tumor.userData.revealed = tumorVisible;
  document.getElementById('btn-tumor').classList.toggle('active', tumorVisible);
  setStatus(tumorVisible
    ? 'ğŸ”´ Tumor visible â€” RIGHT-DRAG on it to cut & extract!'
    : 'Tumor hidden', tumorVisible ? '#ff4444' : '#44ff88');
}

function toggleNerves() {
  nervesOn = !nervesOn;
  allInternals.forEach(o => {
    if (o.userData.name==='nerve' && o.userData.revealed) o.visible = nervesOn;
  });
  document.getElementById('btn-n').classList.toggle('active', nervesOn);
}

function toggleVessels() {
  vesselsOn = !vesselsOn;
  allInternals.forEach(o => {
    if (['artery','portal','bile','hepaticV','lymph'].includes(o.userData.name) && o.userData.revealed)
      o.visible = vesselsOn;
  });
  document.getElementById('btn-v').classList.toggle('active', vesselsOn);
}

function resetAll() {
  wounds.forEach(m => scene.remove(m));
  wounds.length = 0;
  cutCount = 0;
  ncutsEl.textContent = 'Incisions: 0';
  allInternals.forEach(o => { o.visible=false; o.userData.revealed=false; });
  tumor.visible = tumorGlow.visible = false;
  tumor.position.set(0.3, 0.1, 0.2);
  tumorGlow.position.copy(tumor.position);
  tumor.scale.setScalar(1);
  tumorVisible   = false;
  tumorExtracted = false;
  tumorCutPoints = 0;
  document.getElementById('extracted').classList.remove('show');
  document.getElementById('btn-tumor').classList.remove('active');
  setStatus('Reset. Right-drag on liver to cut.'); setMode('EXPLORATION');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VR BUTTON
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let vrBtnAdded = false;
function enterVR() {
  if (!navigator.xr) {
    alert('WebXR not supported in this browser.\nUse Chrome/Edge on a VR headset, or Chrome with the WebXR emulator extension.');
    return;
  }
  navigator.xr.isSessionSupported('immersive-vr').then(supported => {
    if (supported) {
      if (!vrBtnAdded) {
        // Add the official VR button hidden off-screen, then click it
        const vrBtn = THREE.VRButton.createButton(renderer);
        vrBtn.style.display = 'none';
        document.body.appendChild(vrBtn);
        vrBtnAdded = true;
        vrBtn.click();
      }
      document.getElementById('vr-hint').style.opacity = '1';
      setTimeout(()=>document.getElementById('vr-hint').style.opacity='0', 4000);
    } else {
      alert('Immersive VR not supported on this device.\n\nTo use VR:\nâ€¢ Put on a Meta Quest / Valve Index / etc.\nâ€¢ Open this page in the headset browser\nâ€¢ Click ENTER VR');
    }
  });
}

function startSim() {
  document.getElementById('phase-overlay').style.opacity = '0';
  setTimeout(()=>document.getElementById('phase-overlay').style.display='none', 500);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER LOOP (WebXR-compatible)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const clock = new THREE.Clock();

renderer.setAnimationLoop(function() {
  const t = clock.getElapsedTime();
  controls.update();

  // Tumor pulse
  if (tumorGlow.visible) {
    tumorGlow.scale.setScalar(1 + 0.15*Math.sin(t*3.8));
    tumorMat.emissive.setHex(Math.sin(t*3.8)>0 ? 0xcc0000 : 0x880000);
  }

  // Blood
  wounds.forEach(m => {
    if (!m.userData.isBlood) return;
    m.userData.life -= 0.016;
    m.position.y    += m.userData.vy;
    if (m.userData.life<=0) { m.visible=false; return; }
    m.material.opacity = Math.min(1, m.userData.life);
  });

  renderer.render(scene, camera);
});

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
